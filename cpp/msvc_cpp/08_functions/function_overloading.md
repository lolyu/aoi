# function overloading
* C++ allows to specify more than one function of the same name in the same scope.
* At compile-time, the compiler chooses which overload to use based on the types and number of arguments passed in by the caller.
    * **`function signature`: the parameter list of the function**
    * the compiler uses the `function signature` to distinguish among overloads

## overloading considerations
|function declaration element|used for overloading?|
|-|-|
|return type|no|
|number of arguments|yes|
|type of arguments|yes|
|presence or absence of ellipsis|yes|
|`const` or `volatile`|yes, when applied to reference|
|reference qualifiers(`&` or `&&`)|yes|

* **NOTE**: only functions that take different argument initializers could be differentiated by the compiler

```cpp

void f(int i) {}            // [1]
void f(int &i) {}           // [2]
void f(const int i) {}      // [3] not allowed, take the same initializer as [1]
void f(int *p) {}           // [4]
void f(const int *p) {}     // [5]

int main()
{
    f(100);                 // use [1]
    int i = 100;
    f(i);                   // ambiguous call, both [1] and [2] works
    f(&i);
    const int ci = 100;
    f(&ci);
    return 0;
}
```
* for `f(int i)` and `f(int &i)`:
    * if called with a variable, like `f(i)`, it is ambiguous, because those two both can take `i` as argument initializer
    * if called with a literal, like `f(100)`, it is not, because only `f(int i)` could take literal `100` as argument initializer
* `const` and `volatible` could only be used with either reference or pointer to overload function(**not on the base type**)

### function default argument and overload
* the function default argument is not part of a function's type.
    * the default argument allows you to call a function without specifying all of the arguments
    * it does not allow you to create a pointer to the function that does not specify the types of all the arguments
* the type/signature of a function that has default parameters is the same as the type/signature of the function if the parameters were there without any default values
* the default value is replaced in compile time, so the default value must be specified in the function declaration.
    * so in the following example, `foo()` is replaced with `foo(0)` in the compile time.
```cpp
int foo(int a = 0);

foo();
```

```cpp
void f(int i)
{
    cout << i << endl;
}

void f(int i, int j = 100)
{
    cout << i << endl;
    cout << j << endl;
}

// ambiguous function call
// for 100, there are two candidates, f(int i) and f(int i, int j = 100)
f(100);
```

## overloaded function resolution
* the function matching is invoked based on the `best match` among the function declarations in the current scope to the arguments supplied, and **it is done in compile-time**.
* the best match means either:
    * an exact match
    * a trivial conversion was performed
    * an integral promotion was performed
    * a standard conversion to the desired parameter type exists
    * a user-defined conversion(conversion operator or a constructor) to the desired parameter type exists
    * arguments represented by an ellipsis was found
* how to find the match?
    * the compiler creates a set of candidate functions for each argument
        * candidate functions are functions in which the actual argument in that position can be converted to the type of the parameter.
    * for each argument, the best matching function set is selected from the candidate functions.
        * for each argument, there could be multiple best-matching functions
    * and the best match function is selected in the intersection of all the best function sets.
        * if the intersection contains more than one function, an ambiguous error is generated

```cpp
void f2(int i, double d) {}
void f2(double d, int i) {}

f2(10, 10)
```
* for `f2(10, 10)`:
    * for the first argument, the best match function is `void f2(int i, double d)`, which is an exact match.
    * for the second argument, the second match function is `void f2(double d, int i)`, which is an exact match.
    * the intersection is empty, so a ambiguous error is generated by the compiler.

### argument conversions
* when the compiler tries to match arguments against the parameters in function declarations, conversion happens if no exact match can be found.
* the compiler will choose the best implicit conversion sequence among all possible implicit conversion sequences.
* conversion rules:
    * `RULE#1`: only the conversion sequence with at most one user-defined conversion is allowed
    * `RULE#2`: shorter conversion sequence wins
* rank of implicit conversion sequences:
    * exact match
        * no conversion or trivial conversion
        * for trivial conversions, there are two exceptions:
            * conversion to reference/pointer is prefereable than coversion to const reference/pointer
            * regular function is preferable than template function
                * **regular function > explicit specialization > template function**
    * promotion
        * integral promotion
        * float to double conversions
    * standard conversion
        * conversion from derived class pointer to a base class pointer is preferable than conversion to `void *` or `const void *`
        * conversion from derived class pointer to a base class pointer is preferable than conversion to a indirect base class pointer
            * `A` <- `B` <- `C`
            * conversion from pointer to `C` to pointer to `B` is better than conversion from pointer to `C` to pointer to `A`
    * user-defined conversion
        * two conversion sequences with different user-defined conversions are considered equal(`RULE#2` doesn't apply to conversion sequence with user-defined conversions)
    * ellipsis

* trivial conversions:

|Argument type|Converted type|
|-|-|
|type-name|type-name&|
|type-name&|type-name|
|type-name[]|type-name*|
|type-name(argument-list)|(*type-name)(argument-list)|
|type-name|const type-name|
|type-name|volatile type-name|
|type-name*|const type-name*|
|type-name*|volatile type-name*|

```cpp
class UD1
{
    public:
    UD1(int i) {}
};

class UD2
{
    public:
    UD2(long i) {}
};

void f1(UD1 a) {}
void f1(UD2 a) {}

f1(100);    // ambiguous, as conversion sequences with different user-defined conversions are considered equal
```

## overload restrictions
### function overload with array


## references
* https://en.cppreference.com/w/cpp/language/overload_resolution
* https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170
