# task management
* A task is a work unit that a processor could allocate to schedule, execute, and suspend
* two kinds of task-related descriptors in the descriptor table:
    * task state segment descriptor
    * task gate

* 80x86 supports hardware support for multi-tasking

## task structure
* a task consists of two parts:
    * the task execution space
    * the task state segment(TSS)

![image](https://user-images.githubusercontent.com/35479537/231465692-52ffc251-d3e2-4145-8575-4b9bf48f9b6e.png)

* a task is referenced by a segment selector that points to its `TSS`
* When a task is loaded into the processor for execution, then the segment selector, base address, segment length, and TSS segment descriptor attributes of the task are loaded into the task register (`TR`)
* the state of currently running task:
    * the task's current execution space, stored in the segments pointed by the segment selectors in the segment registers:
        * `CS`
        * `DS`
        * `SS`
        * `ES`
        * `FS`
        * `GS`
    * the state of general purpose registers
    * the state of `EFLAGS`, `EIP`, control register `CR3`, task register and `LDTR` register
    * the I/O map base address and I/O map(in the `TSS`)
    * stack pointers to privilege 0, 1, and 2 stacks(in the `TSS`)
    * link to priviously executed task(in the `TSS`)

## task execution
* the OS or the processor could dispatch a task for execution in one of the following methods:
    * a explicit call to a task with `CALL` instruction
    * a explicit jump to a task with `JMP` instruction
    * an implicit call to an interrupt-handler task
    * an implicit call to an exception-handler task
    * a return(`IRET`) when the `NT` flag in the `EFLAGS` register is set
* task switching uses either:
    * a selector that points to the task gate
    * a selector that points to a `TSS`
* when a task switching happens, the execution environment(task context) of the currently running task is saved to its `TSS`, and the execution of the task is suspended, the context of the newly scheduled task is then loaded into the processor and a new task is executed from the loaded `EIP`
* If the currently executing task (the caller) invokes the scheduled new task (the callee), then the caller's `TSS` segment selector is stored in the callee `TSS`, providing a link back to the caller. For all 80X86 processors, tasks are not recursively called, ie tasks cannot be called or jumped to themselves.
* as part of the task switching, the processor also switches to another `LDT`, so different task have different logical-to-physical address mapping, at the same time, the page directory register CR3 is also reloaded at the time of switching, so each task can have its own set of page tables, these protections can be used to isolate individual tasks and prevent them from interfering with each other

## task management data structures
* the processor defines the following registers and data structures that support multitasking:
    * task-state segment(`TSS`)
    * `TSS` descriptor
    * task register(`TR`)
    * task-gate descriptor
    * `NT` flag in the `EFLAGS` register

### task-state segment
![image](https://user-images.githubusercontent.com/35479537/231478532-dad1c838-c0b3-405e-950e-fcb37cf87b54.png)

* task-state segment has two parts: the dynamic fields and static fields

#### TSS descriptor

![image](https://user-images.githubusercontent.com/35479537/233370764-a4adafa2-d80c-42fb-a327-bea6e7e04071.png)

## task switching
* the CPU does task switching in any of four cases:
    * a `JMP` or `CALL` instruction to a `TSS` descriptor in the `GDT`
    * a `JMP` or `CALL` instruction to a task gate descriptor in the `GDT` or the current `LDT`
    * the interrupt ot exception vector points to a task gate descriptor in the `LDT` table
    * the current task executes an `IRET` instruction when the `NT` flag in the `EFLAGS` register is set

![image](https://user-images.githubusercontent.com/35479537/233373886-40b345ce-736d-455e-8437-43389c6bff7b.png)

![image](https://user-images.githubusercontent.com/35479537/233387422-c75cbb8c-edda-46c4-853b-42c4bde58464.png)

### task switching process

1. get the `TSS` segment selector for a new task
    * from the operand of the `JMP` or `CALL` instruction
    * from the task gate
    * from the previous task link of the current `TSS`(`IRET`)
2. check if the current task is allowed to switch to the new task
    * privilege check is needed for `JMP` and `CALL` instruction
    * `CPL` of the current task, the `RPL` of the new task segment selector <= `DPL` of the new task `TSS`
3. validate the new task `TSS` descriptor that the task is present(`P=1`) and the limit is valid(`>0x76`)
4. if the task switch is generated from a `JMP` or `IRET` instruction, the processor will reset the busy flag `B` in the current task (old task) `TSS` descriptor; if the task switch is generated by a `CALL` instruction, exception or interrupt, the busy flag `B` Will not be changed
5. if the task switch is initiated with an `IRET` instruction, the processor resets the `NT` flag in a temporarily saved `EFLAGS` image; if the task switch is initiated with a `CALL`, `JMP` instruction, or an exception or interrupt, the `NT` flag is left unchanged in the saved `EFLAGS` image.
6. save the state of the current task to the `TSS`(the base address of `TSS` is retrieved from the `TR` register)
    * all general purpose registers
    * the segment selector in the segment register
    * `EFLAGS`
    * `EIP`
7. if the task switch was initiated with a CALL instruction, an exception, or an interrupt, the processor sets the NT flag in the EFLAGS image stored in the new taskâ€™s TSS; if initiated with an IRET instruction, the processor restores the NT flag from the EFLAGS image stored on the stack. If initiated with a JMP 
instruction, the NT flag is left unchanged.
8. if the task switch was initiated by a CALL, JMP instruction, or exception or interrupt, the processor sets the busy flag B in the new task TSS descriptor. If the task switch is generated by the IRET, the B flag is not changed.
9. load the new task's `TSS` descriptor and segment selector into task register `TR`
10. load the fields of new task `TSS` into the processor:
    * `LDTR` register
    * `PDBR` register
    * `EFLAGS`
    * `EIP`
    * general purpose registers
    * segment selectors


### task chaining
*  The NT flag indicates whether the currently executing task is nested within the execution of another task, and the previous task link field of the current task holds the TSS selector for the higher level task in the nesting hierarchy, if there is one

![image](https://user-images.githubusercontent.com/35479537/233394982-5a513ba2-4e2b-4b50-929a-da7adee7fcdd.png)


### task address space
*  the `TSS`s for all tasks must be stored in the shared physical address space area, and all tasks can access this area.
*  the linear address space mapped by the `GDT` should also be mapped to the shared physical address space
* to share data between tasks:
    * use the segment descriptor in the `GDT`
        * shared by all tasks
    * shared `LDT`, and the shared `LDT` contains segment descriptors pointing to a shared physical address space
        * shared by limited tasks
    * shared segment descriptor pointing to a shared physical address space


## references
* https://en.wikipedia.org/wiki/Control_register
